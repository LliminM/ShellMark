<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.bcel.util, class: InstructionFinder, interface: CodeConstraint">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="source-line-no">003</span><span id="line-3"> * contributor license agreements.  See the NOTICE file distributed with</span>
<span class="source-line-no">004</span><span id="line-4"> * this work for additional information regarding copyright ownership.</span>
<span class="source-line-no">005</span><span id="line-5"> * The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="source-line-no">006</span><span id="line-6"> * (the "License"); you may not use this file except in compliance with</span>
<span class="source-line-no">007</span><span id="line-7"> * the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">008</span><span id="line-8"> *</span>
<span class="source-line-no">009</span><span id="line-9"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">010</span><span id="line-10"> *</span>
<span class="source-line-no">011</span><span id="line-11"> *  Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">012</span><span id="line-12"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">013</span><span id="line-13"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">014</span><span id="line-14"> *  See the License for the specific language governing permissions and</span>
<span class="source-line-no">015</span><span id="line-15"> *  limitations under the License.</span>
<span class="source-line-no">016</span><span id="line-16"> */</span>
<span class="source-line-no">017</span><span id="line-17">package org.apache.bcel.util;</span>
<span class="source-line-no">018</span><span id="line-18"></span>
<span class="source-line-no">019</span><span id="line-19">import java.util.ArrayList;</span>
<span class="source-line-no">020</span><span id="line-20">import java.util.Arrays;</span>
<span class="source-line-no">021</span><span id="line-21">import java.util.HashMap;</span>
<span class="source-line-no">022</span><span id="line-22">import java.util.Iterator;</span>
<span class="source-line-no">023</span><span id="line-23">import java.util.List;</span>
<span class="source-line-no">024</span><span id="line-24">import java.util.Locale;</span>
<span class="source-line-no">025</span><span id="line-25">import java.util.Map;</span>
<span class="source-line-no">026</span><span id="line-26">import java.util.regex.Matcher;</span>
<span class="source-line-no">027</span><span id="line-27">import java.util.regex.Pattern;</span>
<span class="source-line-no">028</span><span id="line-28"></span>
<span class="source-line-no">029</span><span id="line-29">import org.apache.bcel.Const;</span>
<span class="source-line-no">030</span><span id="line-30">import org.apache.bcel.generic.ClassGenException;</span>
<span class="source-line-no">031</span><span id="line-31">import org.apache.bcel.generic.InstructionHandle;</span>
<span class="source-line-no">032</span><span id="line-32">import org.apache.bcel.generic.InstructionList;</span>
<span class="source-line-no">033</span><span id="line-33"></span>
<span class="source-line-no">034</span><span id="line-34">/**</span>
<span class="source-line-no">035</span><span id="line-35"> * InstructionFinder is a tool to search for given instructions patterns, i.e., match sequences of instructions in an</span>
<span class="source-line-no">036</span><span id="line-36"> * instruction list via regular expressions. This can be used, e.g., in order to implement a peep hole optimizer that</span>
<span class="source-line-no">037</span><span id="line-37"> * looks for code patterns and replaces them with faster equivalents.</span>
<span class="source-line-no">038</span><span id="line-38"> *</span>
<span class="source-line-no">039</span><span id="line-39"> * &lt;p&gt;</span>
<span class="source-line-no">040</span><span id="line-40"> * This class internally uses the java.util.regex package to search for regular expressions.</span>
<span class="source-line-no">041</span><span id="line-41"> *</span>
<span class="source-line-no">042</span><span id="line-42"> * A typical application would look like this:</span>
<span class="source-line-no">043</span><span id="line-43"> *</span>
<span class="source-line-no">044</span><span id="line-44"> * &lt;pre&gt;</span>
<span class="source-line-no">045</span><span id="line-45"> *</span>
<span class="source-line-no">046</span><span id="line-46"> *</span>
<span class="source-line-no">047</span><span id="line-47"> *   InstructionFinder f   = new InstructionFinder(il);</span>
<span class="source-line-no">048</span><span id="line-48"> *   String            pat = &amp;quot;IfInstruction ICONST_0 GOTO ICONST_1 NOP (IFEQ|IFNE)&amp;quot;;</span>
<span class="source-line-no">049</span><span id="line-49"> *</span>
<span class="source-line-no">050</span><span id="line-50"> *   for (Iterator i = f.search(pat, constraint); i.hasNext(); ) {</span>
<span class="source-line-no">051</span><span id="line-51"> *   InstructionHandle[] match = (InstructionHandle[])i.next();</span>
<span class="source-line-no">052</span><span id="line-52"> *   ...</span>
<span class="source-line-no">053</span><span id="line-53"> *   il.delete(match[1], match[5]);</span>
<span class="source-line-no">054</span><span id="line-54"> *   ...</span>
<span class="source-line-no">055</span><span id="line-55"> *   }</span>
<span class="source-line-no">056</span><span id="line-56"> *</span>
<span class="source-line-no">057</span><span id="line-57"> *</span>
<span class="source-line-no">058</span><span id="line-58"> * &lt;/pre&gt;</span>
<span class="source-line-no">059</span><span id="line-59"> *</span>
<span class="source-line-no">060</span><span id="line-60"> * @see org.apache.bcel.generic.Instruction</span>
<span class="source-line-no">061</span><span id="line-61"> * @see InstructionList</span>
<span class="source-line-no">062</span><span id="line-62"> */</span>
<span class="source-line-no">063</span><span id="line-63">public class InstructionFinder {</span>
<span class="source-line-no">064</span><span id="line-64"></span>
<span class="source-line-no">065</span><span id="line-65">    /**</span>
<span class="source-line-no">066</span><span id="line-66">     * Code patterns found may be checked using an additional user-defined constraint object whether they really match the</span>
<span class="source-line-no">067</span><span id="line-67">     * needed criterion. I.e., check constraints that can not expressed with regular expressions.</span>
<span class="source-line-no">068</span><span id="line-68">     */</span>
<span class="source-line-no">069</span><span id="line-69">    public interface CodeConstraint {</span>
<span class="source-line-no">070</span><span id="line-70"></span>
<span class="source-line-no">071</span><span id="line-71">        /**</span>
<span class="source-line-no">072</span><span id="line-72">         * @param match array of instructions matching the requested pattern</span>
<span class="source-line-no">073</span><span id="line-73">         * @return true if the matched area is really useful</span>
<span class="source-line-no">074</span><span id="line-74">         */</span>
<span class="source-line-no">075</span><span id="line-75">        boolean checkCode(InstructionHandle[] match);</span>
<span class="source-line-no">076</span><span id="line-76">    }</span>
<span class="source-line-no">077</span><span id="line-77"></span>
<span class="source-line-no">078</span><span id="line-78">    private static final int OFFSET = 32767; // char + OFFSET is outside of LATIN-1</span>
<span class="source-line-no">079</span><span id="line-79">    private static final int NO_OPCODES = 256; // Potential number, some are not used</span>
<span class="source-line-no">080</span><span id="line-80">    private static final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="source-line-no">081</span><span id="line-81"></span>
<span class="source-line-no">082</span><span id="line-82">    // Initialize pattern map</span>
<span class="source-line-no">083</span><span id="line-83">    static {</span>
<span class="source-line-no">084</span><span id="line-84">        map.put("arithmeticinstruction",</span>
<span class="source-line-no">085</span><span id="line-85">            "(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)");</span>
<span class="source-line-no">086</span><span id="line-86">        map.put("invokeinstruction", "(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)");</span>
<span class="source-line-no">087</span><span id="line-87">        map.put("arrayinstruction",</span>
<span class="source-line-no">088</span><span id="line-88">            "(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)");</span>
<span class="source-line-no">089</span><span id="line-89">        map.put("gotoinstruction", "(goto|goto_w)");</span>
<span class="source-line-no">090</span><span id="line-90">        map.put("conversioninstruction", "(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)");</span>
<span class="source-line-no">091</span><span id="line-91">        map.put("localvariableinstruction", "(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)");</span>
<span class="source-line-no">092</span><span id="line-92">        map.put("loadinstruction", "(fload|dload|lload|iload|aload)");</span>
<span class="source-line-no">093</span><span id="line-93">        map.put("fieldinstruction", "(getfield|putstatic|getstatic|putfield)");</span>
<span class="source-line-no">094</span><span id="line-94">        map.put("cpinstruction",</span>
<span class="source-line-no">095</span><span id="line-95">            "(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)");</span>
<span class="source-line-no">096</span><span id="line-96">        map.put("stackinstruction", "(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)");</span>
<span class="source-line-no">097</span><span id="line-97">        map.put("branchinstruction",</span>
<span class="source-line-no">098</span><span id="line-98">            "(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)");</span>
<span class="source-line-no">099</span><span id="line-99">        map.put("returninstruction", "(lreturn|ireturn|freturn|dreturn|areturn|return)");</span>
<span class="source-line-no">100</span><span id="line-100">        map.put("storeinstruction", "(istore|fstore|dstore|astore|lstore)");</span>
<span class="source-line-no">101</span><span id="line-101">        map.put("select", "(tableswitch|lookupswitch)");</span>
<span class="source-line-no">102</span><span id="line-102">        map.put("ifinstruction",</span>
<span class="source-line-no">103</span><span id="line-103">            "(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)");</span>
<span class="source-line-no">104</span><span id="line-104">        map.put("jsrinstruction", "(jsr|jsr_w)");</span>
<span class="source-line-no">105</span><span id="line-105">        map.put("variablelengthinstruction", "(tableswitch|jsr|goto|lookupswitch)");</span>
<span class="source-line-no">106</span><span id="line-106">        map.put("unconditionalbranch", "(goto|jsr|jsr_w|athrow|goto_w)");</span>
<span class="source-line-no">107</span><span id="line-107">        map.put("constantpushinstruction", "(dconst|bipush|sipush|fconst|iconst|lconst)");</span>
<span class="source-line-no">108</span><span id="line-108">        map.put("typedinstruction",</span>
<span class="source-line-no">109</span><span id="line-109">            "(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)");</span>
<span class="source-line-no">110</span><span id="line-110">        map.put("popinstruction", "(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)");</span>
<span class="source-line-no">111</span><span id="line-111">        map.put("allocationinstruction", "(multianewarray|new|anewarray|newarray)");</span>
<span class="source-line-no">112</span><span id="line-112">        map.put("indexedinstruction",</span>
<span class="source-line-no">113</span><span id="line-113">            "(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)");</span>
<span class="source-line-no">114</span><span id="line-114">        map.put("pushinstruction", "(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)");</span>
<span class="source-line-no">115</span><span id="line-115">        map.put("stackproducer",</span>
<span class="source-line-no">116</span><span id="line-116">            "(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)");</span>
<span class="source-line-no">117</span><span id="line-117">        map.put("stackconsumer",</span>
<span class="source-line-no">118</span><span id="line-118">            "(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)");</span>
<span class="source-line-no">119</span><span id="line-119">        map.put("exceptionthrower",</span>
<span class="source-line-no">120</span><span id="line-120">            "(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)");</span>
<span class="source-line-no">121</span><span id="line-121">        map.put("loadclass",</span>
<span class="source-line-no">122</span><span id="line-122">            "(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)");</span>
<span class="source-line-no">123</span><span id="line-123">        map.put("instructiontargeter",</span>
<span class="source-line-no">124</span><span id="line-124">            "(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)");</span>
<span class="source-line-no">125</span><span id="line-125">        // Some aliases</span>
<span class="source-line-no">126</span><span id="line-126">        map.put("if_icmp", "(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)");</span>
<span class="source-line-no">127</span><span id="line-127">        map.put("if_acmp", "(if_acmpeq|if_acmpne)");</span>
<span class="source-line-no">128</span><span id="line-128">        map.put("if", "(ifeq|ifne|iflt|ifge|ifgt|ifle)");</span>
<span class="source-line-no">129</span><span id="line-129">        // Precompile some aliases first</span>
<span class="source-line-no">130</span><span id="line-130">        map.put("iconst", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));</span>
<span class="source-line-no">131</span><span id="line-131">        map.put("lconst", new String(new char[] {'(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')'}));</span>
<span class="source-line-no">132</span><span id="line-132">        map.put("dconst", new String(new char[] {'(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')'}));</span>
<span class="source-line-no">133</span><span id="line-133">        map.put("fconst", new String(new char[] {'(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')'}));</span>
<span class="source-line-no">134</span><span id="line-134">        map.put("lload", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));</span>
<span class="source-line-no">135</span><span id="line-135">        map.put("iload", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));</span>
<span class="source-line-no">136</span><span id="line-136">        map.put("dload", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));</span>
<span class="source-line-no">137</span><span id="line-137">        map.put("fload", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));</span>
<span class="source-line-no">138</span><span id="line-138">        map.put("aload", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));</span>
<span class="source-line-no">139</span><span id="line-139">        map.put("lstore", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));</span>
<span class="source-line-no">140</span><span id="line-140">        map.put("istore", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));</span>
<span class="source-line-no">141</span><span id="line-141">        map.put("dstore", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));</span>
<span class="source-line-no">142</span><span id="line-142">        map.put("fstore", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));</span>
<span class="source-line-no">143</span><span id="line-143">        map.put("astore", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));</span>
<span class="source-line-no">144</span><span id="line-144">        // Compile strings</span>
<span class="source-line-no">145</span><span id="line-145">        map.forEach((key, value) -&gt; {</span>
<span class="source-line-no">146</span><span id="line-146">            final char ch = value.charAt(1); // Omit already precompiled patterns</span>
<span class="source-line-no">147</span><span id="line-147">            if (ch &lt; OFFSET) {</span>
<span class="source-line-no">148</span><span id="line-148">                map.put(key, compilePattern(value)); // precompile all patterns</span>
<span class="source-line-no">149</span><span id="line-149">            }</span>
<span class="source-line-no">150</span><span id="line-150">        });</span>
<span class="source-line-no">151</span><span id="line-151">        // Add instruction alias to match anything</span>
<span class="source-line-no">152</span><span id="line-152">        final StringBuilder buf = new StringBuilder("(");</span>
<span class="source-line-no">153</span><span id="line-153">        for (short i = 0; i &lt; NO_OPCODES; i++) {</span>
<span class="source-line-no">154</span><span id="line-154">            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { // Not an invalid opcode</span>
<span class="source-line-no">155</span><span id="line-155">                buf.append(makeChar(i));</span>
<span class="source-line-no">156</span><span id="line-156">                if (i &lt; NO_OPCODES - 1) {</span>
<span class="source-line-no">157</span><span id="line-157">                    buf.append('|');</span>
<span class="source-line-no">158</span><span id="line-158">                }</span>
<span class="source-line-no">159</span><span id="line-159">            }</span>
<span class="source-line-no">160</span><span id="line-160">        }</span>
<span class="source-line-no">161</span><span id="line-161">        buf.append(')');</span>
<span class="source-line-no">162</span><span id="line-162">        map.put("instruction", buf.toString());</span>
<span class="source-line-no">163</span><span id="line-163">    }</span>
<span class="source-line-no">164</span><span id="line-164"></span>
<span class="source-line-no">165</span><span id="line-165">    /**</span>
<span class="source-line-no">166</span><span id="line-166">     * Replace symbolic names of instructions with the appropriate character and remove all white space from string. Meta</span>
<span class="source-line-no">167</span><span id="line-167">     * characters such as +, * are ignored.</span>
<span class="source-line-no">168</span><span id="line-168">     *</span>
<span class="source-line-no">169</span><span id="line-169">     * @param pattern The pattern to compile</span>
<span class="source-line-no">170</span><span id="line-170">     * @return translated regular expression string</span>
<span class="source-line-no">171</span><span id="line-171">     */</span>
<span class="source-line-no">172</span><span id="line-172">    private static String compilePattern(final String pattern) {</span>
<span class="source-line-no">173</span><span id="line-173">        // Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues</span>
<span class="source-line-no">174</span><span id="line-174">        final String lower = pattern.toLowerCase(Locale.ENGLISH);</span>
<span class="source-line-no">175</span><span id="line-175">        final StringBuilder buf = new StringBuilder();</span>
<span class="source-line-no">176</span><span id="line-176">        final int size = pattern.length();</span>
<span class="source-line-no">177</span><span id="line-177">        for (int i = 0; i &lt; size; i++) {</span>
<span class="source-line-no">178</span><span id="line-178">            char ch = lower.charAt(i);</span>
<span class="source-line-no">179</span><span id="line-179">            if (Character.isLetterOrDigit(ch)) {</span>
<span class="source-line-no">180</span><span id="line-180">                final StringBuilder name = new StringBuilder();</span>
<span class="source-line-no">181</span><span id="line-181">                while ((Character.isLetterOrDigit(ch) || ch == '_') &amp;&amp; i &lt; size) {</span>
<span class="source-line-no">182</span><span id="line-182">                    name.append(ch);</span>
<span class="source-line-no">183</span><span id="line-183">                    if (++i &gt;= size) {</span>
<span class="source-line-no">184</span><span id="line-184">                        break;</span>
<span class="source-line-no">185</span><span id="line-185">                    }</span>
<span class="source-line-no">186</span><span id="line-186">                    ch = lower.charAt(i);</span>
<span class="source-line-no">187</span><span id="line-187">                }</span>
<span class="source-line-no">188</span><span id="line-188">                i--;</span>
<span class="source-line-no">189</span><span id="line-189">                buf.append(mapName(name.toString()));</span>
<span class="source-line-no">190</span><span id="line-190">            } else if (!Character.isWhitespace(ch)) {</span>
<span class="source-line-no">191</span><span id="line-191">                buf.append(ch);</span>
<span class="source-line-no">192</span><span id="line-192">            }</span>
<span class="source-line-no">193</span><span id="line-193">        }</span>
<span class="source-line-no">194</span><span id="line-194">        return buf.toString();</span>
<span class="source-line-no">195</span><span id="line-195">    }</span>
<span class="source-line-no">196</span><span id="line-196"></span>
<span class="source-line-no">197</span><span id="line-197">    /**</span>
<span class="source-line-no">198</span><span id="line-198">     * Convert opcode number to char.</span>
<span class="source-line-no">199</span><span id="line-199">     */</span>
<span class="source-line-no">200</span><span id="line-200">    private static char makeChar(final short opcode) {</span>
<span class="source-line-no">201</span><span id="line-201">        return (char) (opcode + OFFSET);</span>
<span class="source-line-no">202</span><span id="line-202">    }</span>
<span class="source-line-no">203</span><span id="line-203"></span>
<span class="source-line-no">204</span><span id="line-204">    /**</span>
<span class="source-line-no">205</span><span id="line-205">     * Map symbolic instruction names like "getfield" to a single character.</span>
<span class="source-line-no">206</span><span id="line-206">     *</span>
<span class="source-line-no">207</span><span id="line-207">     * @param pattern instruction pattern in lower case</span>
<span class="source-line-no">208</span><span id="line-208">     * @return encoded string for a pattern such as "BranchInstruction".</span>
<span class="source-line-no">209</span><span id="line-209">     */</span>
<span class="source-line-no">210</span><span id="line-210">    private static String mapName(final String pattern) {</span>
<span class="source-line-no">211</span><span id="line-211">        final String result = map.get(pattern);</span>
<span class="source-line-no">212</span><span id="line-212">        if (result != null) {</span>
<span class="source-line-no">213</span><span id="line-213">            return result;</span>
<span class="source-line-no">214</span><span id="line-214">        }</span>
<span class="source-line-no">215</span><span id="line-215">        for (short i = 0; i &lt; NO_OPCODES; i++) {</span>
<span class="source-line-no">216</span><span id="line-216">            if (pattern.equals(Const.getOpcodeName(i))) {</span>
<span class="source-line-no">217</span><span id="line-217">                return String.valueOf(makeChar(i));</span>
<span class="source-line-no">218</span><span id="line-218">            }</span>
<span class="source-line-no">219</span><span id="line-219">        }</span>
<span class="source-line-no">220</span><span id="line-220">        throw new IllegalArgumentException("Instruction unknown: " + pattern);</span>
<span class="source-line-no">221</span><span id="line-221">    }</span>
<span class="source-line-no">222</span><span id="line-222"></span>
<span class="source-line-no">223</span><span id="line-223">    private static String precompile(final short from, final short to, final short extra) {</span>
<span class="source-line-no">224</span><span id="line-224">        final StringBuilder buf = new StringBuilder("(");</span>
<span class="source-line-no">225</span><span id="line-225">        for (short i = from; i &lt;= to; i++) {</span>
<span class="source-line-no">226</span><span id="line-226">            buf.append(makeChar(i));</span>
<span class="source-line-no">227</span><span id="line-227">            buf.append('|');</span>
<span class="source-line-no">228</span><span id="line-228">        }</span>
<span class="source-line-no">229</span><span id="line-229">        buf.append(makeChar(extra));</span>
<span class="source-line-no">230</span><span id="line-230">        buf.append(")");</span>
<span class="source-line-no">231</span><span id="line-231">        return buf.toString();</span>
<span class="source-line-no">232</span><span id="line-232">    }</span>
<span class="source-line-no">233</span><span id="line-233"></span>
<span class="source-line-no">234</span><span id="line-234">    private final InstructionList il;</span>
<span class="source-line-no">235</span><span id="line-235"></span>
<span class="source-line-no">236</span><span id="line-236">    private String ilString; // instruction list as string</span>
<span class="source-line-no">237</span><span id="line-237"></span>
<span class="source-line-no">238</span><span id="line-238">    private InstructionHandle[] handles; // map instruction</span>
<span class="source-line-no">239</span><span id="line-239"></span>
<span class="source-line-no">240</span><span id="line-240">    // list to array</span>
<span class="source-line-no">241</span><span id="line-241">    /**</span>
<span class="source-line-no">242</span><span id="line-242">     * @param il instruction list to search for given patterns</span>
<span class="source-line-no">243</span><span id="line-243">     */</span>
<span class="source-line-no">244</span><span id="line-244">    public InstructionFinder(final InstructionList il) {</span>
<span class="source-line-no">245</span><span id="line-245">        this.il = il;</span>
<span class="source-line-no">246</span><span id="line-246">        reread();</span>
<span class="source-line-no">247</span><span id="line-247">    }</span>
<span class="source-line-no">248</span><span id="line-248"></span>
<span class="source-line-no">249</span><span id="line-249">    /**</span>
<span class="source-line-no">250</span><span id="line-250">     * @return the inquired instruction list</span>
<span class="source-line-no">251</span><span id="line-251">     */</span>
<span class="source-line-no">252</span><span id="line-252">    public final InstructionList getInstructionList() {</span>
<span class="source-line-no">253</span><span id="line-253">        return il;</span>
<span class="source-line-no">254</span><span id="line-254">    }</span>
<span class="source-line-no">255</span><span id="line-255"></span>
<span class="source-line-no">256</span><span id="line-256">    /**</span>
<span class="source-line-no">257</span><span id="line-257">     * @return the matched piece of code as an array of instruction (handles)</span>
<span class="source-line-no">258</span><span id="line-258">     */</span>
<span class="source-line-no">259</span><span id="line-259">    private InstructionHandle[] getMatch(final int matchedFrom, final int matchLength) {</span>
<span class="source-line-no">260</span><span id="line-260">        return Arrays.copyOfRange(handles, matchedFrom, matchedFrom + matchLength);</span>
<span class="source-line-no">261</span><span id="line-261">    }</span>
<span class="source-line-no">262</span><span id="line-262"></span>
<span class="source-line-no">263</span><span id="line-263">    /**</span>
<span class="source-line-no">264</span><span id="line-264">     * Reread the instruction list, e.g., after you've altered the list upon a match.</span>
<span class="source-line-no">265</span><span id="line-265">     */</span>
<span class="source-line-no">266</span><span id="line-266">    public final void reread() {</span>
<span class="source-line-no">267</span><span id="line-267">        final int size = il.getLength();</span>
<span class="source-line-no">268</span><span id="line-268">        final char[] buf = new char[size]; // Create a string with length equal to il length</span>
<span class="source-line-no">269</span><span id="line-269">        handles = il.getInstructionHandles();</span>
<span class="source-line-no">270</span><span id="line-270">        // Map opcodes to characters</span>
<span class="source-line-no">271</span><span id="line-271">        for (int i = 0; i &lt; size; i++) {</span>
<span class="source-line-no">272</span><span id="line-272">            buf[i] = makeChar(handles[i].getInstruction().getOpcode());</span>
<span class="source-line-no">273</span><span id="line-273">        }</span>
<span class="source-line-no">274</span><span id="line-274">        ilString = new String(buf);</span>
<span class="source-line-no">275</span><span id="line-275">    }</span>
<span class="source-line-no">276</span><span id="line-276"></span>
<span class="source-line-no">277</span><span id="line-277">    /**</span>
<span class="source-line-no">278</span><span id="line-278">     * Start search beginning from the start of the given instruction list.</span>
<span class="source-line-no">279</span><span id="line-279">     *</span>
<span class="source-line-no">280</span><span id="line-280">     * @param pattern the instruction pattern to search for, where case is ignored</span>
<span class="source-line-no">281</span><span id="line-281">     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area</span>
<span class="source-line-no">282</span><span id="line-282">     */</span>
<span class="source-line-no">283</span><span id="line-283">    public final Iterator&lt;InstructionHandle[]&gt; search(final String pattern) {</span>
<span class="source-line-no">284</span><span id="line-284">        return search(pattern, il.getStart(), null);</span>
<span class="source-line-no">285</span><span id="line-285">    }</span>
<span class="source-line-no">286</span><span id="line-286"></span>
<span class="source-line-no">287</span><span id="line-287">    /**</span>
<span class="source-line-no">288</span><span id="line-288">     * Start search beginning from the start of the given instruction list. Check found matches with the constraint object.</span>
<span class="source-line-no">289</span><span id="line-289">     *</span>
<span class="source-line-no">290</span><span id="line-290">     * @param pattern the instruction pattern to search for, case is ignored</span>
<span class="source-line-no">291</span><span id="line-291">     * @param constraint constraints to be checked on matching code</span>
<span class="source-line-no">292</span><span id="line-292">     * @return instruction handle or 'null' if the match failed</span>
<span class="source-line-no">293</span><span id="line-293">     */</span>
<span class="source-line-no">294</span><span id="line-294">    public final Iterator&lt;InstructionHandle[]&gt; search(final String pattern, final CodeConstraint constraint) {</span>
<span class="source-line-no">295</span><span id="line-295">        return search(pattern, il.getStart(), constraint);</span>
<span class="source-line-no">296</span><span id="line-296">    }</span>
<span class="source-line-no">297</span><span id="line-297"></span>
<span class="source-line-no">298</span><span id="line-298">    /**</span>
<span class="source-line-no">299</span><span id="line-299">     * Start search beginning from 'from'.</span>
<span class="source-line-no">300</span><span id="line-300">     *</span>
<span class="source-line-no">301</span><span id="line-301">     * @param pattern the instruction pattern to search for, where case is ignored</span>
<span class="source-line-no">302</span><span id="line-302">     * @param from where to start the search in the instruction list</span>
<span class="source-line-no">303</span><span id="line-303">     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area</span>
<span class="source-line-no">304</span><span id="line-304">     */</span>
<span class="source-line-no">305</span><span id="line-305">    public final Iterator&lt;InstructionHandle[]&gt; search(final String pattern, final InstructionHandle from) {</span>
<span class="source-line-no">306</span><span id="line-306">        return search(pattern, from, null);</span>
<span class="source-line-no">307</span><span id="line-307">    }</span>
<span class="source-line-no">308</span><span id="line-308"></span>
<span class="source-line-no">309</span><span id="line-309">    /**</span>
<span class="source-line-no">310</span><span id="line-310">     * Search for the given pattern in the instruction list. You can search for any valid opcode via its symbolic name, e.g.</span>
<span class="source-line-no">311</span><span id="line-311">     * "istore". You can also use a super class or an interface name to match a whole set of instructions, e.g.</span>
<span class="source-line-no">312</span><span id="line-312">     * "BranchInstruction" or "LoadInstruction". "istore" is also an alias for all "istore_x" instructions. Additional</span>
<span class="source-line-no">313</span><span id="line-313">     * aliases are "if" for "ifxx", "if_icmp" for "if_icmpxx", "if_acmp" for "if_acmpxx".</span>
<span class="source-line-no">314</span><span id="line-314">     *</span>
<span class="source-line-no">315</span><span id="line-315">     * Consecutive instruction names must be separated by white space which will be removed during the compilation of the</span>
<span class="source-line-no">316</span><span id="line-316">     * pattern.</span>
<span class="source-line-no">317</span><span id="line-317">     *</span>
<span class="source-line-no">318</span><span id="line-318">     * For the rest the usual pattern matching rules for regular expressions apply.</span>
<span class="source-line-no">319</span><span id="line-319">     * &lt;P&gt;</span>
<span class="source-line-no">320</span><span id="line-320">     * Example pattern:</span>
<span class="source-line-no">321</span><span id="line-321">     *</span>
<span class="source-line-no">322</span><span id="line-322">     * &lt;pre&gt;</span>
<span class="source-line-no">323</span><span id="line-323">     * search(&amp;quot;BranchInstruction NOP ((IfInstruction|GOTO)+ ISTORE Instruction)*&amp;quot;);</span>
<span class="source-line-no">324</span><span id="line-324">     * &lt;/pre&gt;</span>
<span class="source-line-no">325</span><span id="line-325">     *</span>
<span class="source-line-no">326</span><span id="line-326">     * &lt;p&gt;</span>
<span class="source-line-no">327</span><span id="line-327">     * If you alter the instruction list upon a match such that other matching areas are affected, you should call reread()</span>
<span class="source-line-no">328</span><span id="line-328">     * to update the finder and call search() again, because the matches are cached.</span>
<span class="source-line-no">329</span><span id="line-329">     *</span>
<span class="source-line-no">330</span><span id="line-330">     * @param pattern the instruction pattern to search for, where case is ignored</span>
<span class="source-line-no">331</span><span id="line-331">     * @param from where to start the search in the instruction list</span>
<span class="source-line-no">332</span><span id="line-332">     * @param constraint optional CodeConstraint to check the found code pattern for user-defined constraints</span>
<span class="source-line-no">333</span><span id="line-333">     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area</span>
<span class="source-line-no">334</span><span id="line-334">     */</span>
<span class="source-line-no">335</span><span id="line-335">    public final Iterator&lt;InstructionHandle[]&gt; search(final String pattern, final InstructionHandle from, final CodeConstraint constraint) {</span>
<span class="source-line-no">336</span><span id="line-336">        final String search = compilePattern(pattern);</span>
<span class="source-line-no">337</span><span id="line-337">        int start = -1;</span>
<span class="source-line-no">338</span><span id="line-338">        for (int i = 0; i &lt; handles.length; i++) {</span>
<span class="source-line-no">339</span><span id="line-339">            if (handles[i] == from) {</span>
<span class="source-line-no">340</span><span id="line-340">                start = i; // Where to start search from (index)</span>
<span class="source-line-no">341</span><span id="line-341">                break;</span>
<span class="source-line-no">342</span><span id="line-342">            }</span>
<span class="source-line-no">343</span><span id="line-343">        }</span>
<span class="source-line-no">344</span><span id="line-344">        if (start == -1) {</span>
<span class="source-line-no">345</span><span id="line-345">            throw new ClassGenException("Instruction handle " + from + " not found in instruction list.");</span>
<span class="source-line-no">346</span><span id="line-346">        }</span>
<span class="source-line-no">347</span><span id="line-347">        final Pattern regex = Pattern.compile(search);</span>
<span class="source-line-no">348</span><span id="line-348">        final List&lt;InstructionHandle[]&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">349</span><span id="line-349">        final Matcher matcher = regex.matcher(ilString);</span>
<span class="source-line-no">350</span><span id="line-350">        while (start &lt; ilString.length() &amp;&amp; matcher.find(start)) {</span>
<span class="source-line-no">351</span><span id="line-351">            final int startExpr = matcher.start();</span>
<span class="source-line-no">352</span><span id="line-352">            final int endExpr = matcher.end();</span>
<span class="source-line-no">353</span><span id="line-353">            final int lenExpr = endExpr - startExpr;</span>
<span class="source-line-no">354</span><span id="line-354">            final InstructionHandle[] match = getMatch(startExpr, lenExpr);</span>
<span class="source-line-no">355</span><span id="line-355">            if (constraint == null || constraint.checkCode(match)) {</span>
<span class="source-line-no">356</span><span id="line-356">                matches.add(match);</span>
<span class="source-line-no">357</span><span id="line-357">            }</span>
<span class="source-line-no">358</span><span id="line-358">            start = endExpr;</span>
<span class="source-line-no">359</span><span id="line-359">        }</span>
<span class="source-line-no">360</span><span id="line-360">        return matches.iterator();</span>
<span class="source-line-no">361</span><span id="line-361">    }</span>
<span class="source-line-no">362</span><span id="line-362"></span>
<span class="source-line-no">363</span><span id="line-363">    /*</span>
<span class="source-line-no">364</span><span id="line-364">     * Internal debugging routines.</span>
<span class="source-line-no">365</span><span id="line-365">     */</span>
<span class="source-line-no">366</span><span id="line-366">//    private static final String pattern2string( String pattern ) {</span>
<span class="source-line-no">367</span><span id="line-367">//        return pattern2string(pattern, true);</span>
<span class="source-line-no">368</span><span id="line-368">//    }</span>
<span class="source-line-no">369</span><span id="line-369"></span>
<span class="source-line-no">370</span><span id="line-370">//    private static final String pattern2string( String pattern, boolean make_string ) {</span>
<span class="source-line-no">371</span><span id="line-371">//        StringBuilder buf = new StringBuilder();</span>
<span class="source-line-no">372</span><span id="line-372">//        for (int i = 0; i &lt; pattern.length(); i++) {</span>
<span class="source-line-no">373</span><span id="line-373">//            char ch = pattern.charAt(i);</span>
<span class="source-line-no">374</span><span id="line-374">//            if (ch &gt;= OFFSET) {</span>
<span class="source-line-no">375</span><span id="line-375">//                if (make_string) {</span>
<span class="source-line-no">376</span><span id="line-376">//                    buf.append(Constants.getOpcodeName(ch - OFFSET));</span>
<span class="source-line-no">377</span><span id="line-377">//                } else {</span>
<span class="source-line-no">378</span><span id="line-378">//                    buf.append((ch - OFFSET));</span>
<span class="source-line-no">379</span><span id="line-379">//                }</span>
<span class="source-line-no">380</span><span id="line-380">//            } else {</span>
<span class="source-line-no">381</span><span id="line-381">//                buf.append(ch);</span>
<span class="source-line-no">382</span><span id="line-382">//            }</span>
<span class="source-line-no">383</span><span id="line-383">//        }</span>
<span class="source-line-no">384</span><span id="line-384">//        return buf.toString();</span>
<span class="source-line-no">385</span><span id="line-385">//    }</span>
<span class="source-line-no">386</span><span id="line-386">}</span>




























































</pre>
</div>
</main>
</body>
</html>
