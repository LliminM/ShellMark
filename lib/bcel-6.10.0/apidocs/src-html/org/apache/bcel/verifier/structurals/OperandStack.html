<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.bcel.verifier.structurals, class: OperandStack">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="source-line-no">003</span><span id="line-3"> * contributor license agreements.  See the NOTICE file distributed with</span>
<span class="source-line-no">004</span><span id="line-4"> * this work for additional information regarding copyright ownership.</span>
<span class="source-line-no">005</span><span id="line-5"> * The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="source-line-no">006</span><span id="line-6"> * (the "License"); you may not use this file except in compliance with</span>
<span class="source-line-no">007</span><span id="line-7"> * the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">008</span><span id="line-8"> *</span>
<span class="source-line-no">009</span><span id="line-9"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">010</span><span id="line-10"> *</span>
<span class="source-line-no">011</span><span id="line-11"> *  Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">012</span><span id="line-12"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">013</span><span id="line-13"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">014</span><span id="line-14"> *  See the License for the specific language governing permissions and</span>
<span class="source-line-no">015</span><span id="line-15"> *  limitations under the License.</span>
<span class="source-line-no">016</span><span id="line-16"> */</span>
<span class="source-line-no">017</span><span id="line-17">package org.apache.bcel.verifier.structurals;</span>
<span class="source-line-no">018</span><span id="line-18"></span>
<span class="source-line-no">019</span><span id="line-19">import java.util.ArrayList;</span>
<span class="source-line-no">020</span><span id="line-20"></span>
<span class="source-line-no">021</span><span id="line-21">import org.apache.bcel.generic.ObjectType;</span>
<span class="source-line-no">022</span><span id="line-22">import org.apache.bcel.generic.ReferenceType;</span>
<span class="source-line-no">023</span><span id="line-23">import org.apache.bcel.generic.Type;</span>
<span class="source-line-no">024</span><span id="line-24">import org.apache.bcel.verifier.exc.AssertionViolatedException;</span>
<span class="source-line-no">025</span><span id="line-25">import org.apache.bcel.verifier.exc.StructuralCodeConstraintException;</span>
<span class="source-line-no">026</span><span id="line-26"></span>
<span class="source-line-no">027</span><span id="line-27">/**</span>
<span class="source-line-no">028</span><span id="line-28"> * This class implements a stack used for symbolic JVM stack simulation. [It's used as an operand stack substitute.]</span>
<span class="source-line-no">029</span><span id="line-29"> * Elements of this stack are {@link Type} objects.</span>
<span class="source-line-no">030</span><span id="line-30"> */</span>
<span class="source-line-no">031</span><span id="line-31">public class OperandStack implements Cloneable {</span>
<span class="source-line-no">032</span><span id="line-32"></span>
<span class="source-line-no">033</span><span id="line-33">    /** We hold the stack information here. */</span>
<span class="source-line-no">034</span><span id="line-34">    private ArrayList&lt;Type&gt; stack = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">035</span><span id="line-35"></span>
<span class="source-line-no">036</span><span id="line-36">    /** The maximum number of stack slots this OperandStack instance may hold. */</span>
<span class="source-line-no">037</span><span id="line-37">    private final int maxStack;</span>
<span class="source-line-no">038</span><span id="line-38"></span>
<span class="source-line-no">039</span><span id="line-39">    /**</span>
<span class="source-line-no">040</span><span id="line-40">     * Creates an empty stack with a maximum of maxStack slots.</span>
<span class="source-line-no">041</span><span id="line-41">     */</span>
<span class="source-line-no">042</span><span id="line-42">    public OperandStack(final int maxStack) {</span>
<span class="source-line-no">043</span><span id="line-43">        this.maxStack = maxStack;</span>
<span class="source-line-no">044</span><span id="line-44">    }</span>
<span class="source-line-no">045</span><span id="line-45"></span>
<span class="source-line-no">046</span><span id="line-46">    /**</span>
<span class="source-line-no">047</span><span id="line-47">     * Creates an otherwise empty stack with a maximum of maxStack slots and the ObjectType 'obj' at the top.</span>
<span class="source-line-no">048</span><span id="line-48">     */</span>
<span class="source-line-no">049</span><span id="line-49">    public OperandStack(final int maxStack, final ObjectType obj) {</span>
<span class="source-line-no">050</span><span id="line-50">        this.maxStack = maxStack;</span>
<span class="source-line-no">051</span><span id="line-51">        push(obj);</span>
<span class="source-line-no">052</span><span id="line-52">    }</span>
<span class="source-line-no">053</span><span id="line-53"></span>
<span class="source-line-no">054</span><span id="line-54">    /**</span>
<span class="source-line-no">055</span><span id="line-55">     * Clears the stack.</span>
<span class="source-line-no">056</span><span id="line-56">     */</span>
<span class="source-line-no">057</span><span id="line-57">    public void clear() {</span>
<span class="source-line-no">058</span><span id="line-58">        stack = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">059</span><span id="line-59">    }</span>
<span class="source-line-no">060</span><span id="line-60"></span>
<span class="source-line-no">061</span><span id="line-61">    /**</span>
<span class="source-line-no">062</span><span id="line-62">     * Returns a deep copy of this object; that means, the clone operates on a new stack. However, the Type objects on the</span>
<span class="source-line-no">063</span><span id="line-63">     * stack are shared.</span>
<span class="source-line-no">064</span><span id="line-64">     */</span>
<span class="source-line-no">065</span><span id="line-65">    @Override</span>
<span class="source-line-no">066</span><span id="line-66">    public Object clone() {</span>
<span class="source-line-no">067</span><span id="line-67">        final OperandStack newstack = new OperandStack(this.maxStack);</span>
<span class="source-line-no">068</span><span id="line-68">        @SuppressWarnings("unchecked") // OK because this.stack is the same type</span>
<span class="source-line-no">069</span><span id="line-69">        final ArrayList&lt;Type&gt; clone = (ArrayList&lt;Type&gt;) this.stack.clone();</span>
<span class="source-line-no">070</span><span id="line-70">        newstack.stack = clone;</span>
<span class="source-line-no">071</span><span id="line-71">        return newstack;</span>
<span class="source-line-no">072</span><span id="line-72">    }</span>
<span class="source-line-no">073</span><span id="line-73"></span>
<span class="source-line-no">074</span><span id="line-74">    /**</span>
<span class="source-line-no">075</span><span id="line-75">     * Returns true if and only if this OperandStack equals another, meaning equal lengths and equal objects on the stacks.</span>
<span class="source-line-no">076</span><span id="line-76">     */</span>
<span class="source-line-no">077</span><span id="line-77">    @Override</span>
<span class="source-line-no">078</span><span id="line-78">    public boolean equals(final Object o) {</span>
<span class="source-line-no">079</span><span id="line-79">        if (!(o instanceof OperandStack)) {</span>
<span class="source-line-no">080</span><span id="line-80">            return false;</span>
<span class="source-line-no">081</span><span id="line-81">        }</span>
<span class="source-line-no">082</span><span id="line-82">        final OperandStack s = (OperandStack) o;</span>
<span class="source-line-no">083</span><span id="line-83">        return this.stack.equals(s.stack);</span>
<span class="source-line-no">084</span><span id="line-84">    }</span>
<span class="source-line-no">085</span><span id="line-85"></span>
<span class="source-line-no">086</span><span id="line-86">    /**</span>
<span class="source-line-no">087</span><span id="line-87">     * Returns a (typed!) clone of this.</span>
<span class="source-line-no">088</span><span id="line-88">     *</span>
<span class="source-line-no">089</span><span id="line-89">     * @see #clone()</span>
<span class="source-line-no">090</span><span id="line-90">     */</span>
<span class="source-line-no">091</span><span id="line-91">    public OperandStack getClone() {</span>
<span class="source-line-no">092</span><span id="line-92">        return (OperandStack) clone();</span>
<span class="source-line-no">093</span><span id="line-93">    }</span>
<span class="source-line-no">094</span><span id="line-94"></span>
<span class="source-line-no">095</span><span id="line-95">    /**</span>
<span class="source-line-no">096</span><span id="line-96">     * @return a hash code value for the object.</span>
<span class="source-line-no">097</span><span id="line-97">     */</span>
<span class="source-line-no">098</span><span id="line-98">    @Override</span>
<span class="source-line-no">099</span><span id="line-99">    public int hashCode() {</span>
<span class="source-line-no">100</span><span id="line-100">        return stack.hashCode();</span>
<span class="source-line-no">101</span><span id="line-101">    }</span>
<span class="source-line-no">102</span><span id="line-102"></span>
<span class="source-line-no">103</span><span id="line-103">    /**</span>
<span class="source-line-no">104</span><span id="line-104">     * Replaces all occurrences of u in this OperandStack instance with an "initialized" ObjectType.</span>
<span class="source-line-no">105</span><span id="line-105">     */</span>
<span class="source-line-no">106</span><span id="line-106">    public void initializeObject(final UninitializedObjectType u) {</span>
<span class="source-line-no">107</span><span id="line-107">        for (int i = 0; i &lt; stack.size(); i++) {</span>
<span class="source-line-no">108</span><span id="line-108">            if (stack.get(i) == u) {</span>
<span class="source-line-no">109</span><span id="line-109">                stack.set(i, u.getInitialized());</span>
<span class="source-line-no">110</span><span id="line-110">            }</span>
<span class="source-line-no">111</span><span id="line-111">        }</span>
<span class="source-line-no">112</span><span id="line-112">    }</span>
<span class="source-line-no">113</span><span id="line-113"></span>
<span class="source-line-no">114</span><span id="line-114">    /**</span>
<span class="source-line-no">115</span><span id="line-115">     * Returns true IFF this OperandStack is empty.</span>
<span class="source-line-no">116</span><span id="line-116">     */</span>
<span class="source-line-no">117</span><span id="line-117">    public boolean isEmpty() {</span>
<span class="source-line-no">118</span><span id="line-118">        return stack.isEmpty();</span>
<span class="source-line-no">119</span><span id="line-119">    }</span>
<span class="source-line-no">120</span><span id="line-120"></span>
<span class="source-line-no">121</span><span id="line-121">    /**</span>
<span class="source-line-no">122</span><span id="line-122">     * Returns the number of stack slots this stack can hold.</span>
<span class="source-line-no">123</span><span id="line-123">     */</span>
<span class="source-line-no">124</span><span id="line-124">    public int maxStack() {</span>
<span class="source-line-no">125</span><span id="line-125">        return this.maxStack;</span>
<span class="source-line-no">126</span><span id="line-126">    }</span>
<span class="source-line-no">127</span><span id="line-127"></span>
<span class="source-line-no">128</span><span id="line-128">    /**</span>
<span class="source-line-no">129</span><span id="line-129">     * Merges another stack state into this instance's stack state. See the Java Virtual Machine Specification, Second</span>
<span class="source-line-no">130</span><span id="line-130">     * Edition, page 146: 4.9.2 for details.</span>
<span class="source-line-no">131</span><span id="line-131">     */</span>
<span class="source-line-no">132</span><span id="line-132">    public void merge(final OperandStack s) {</span>
<span class="source-line-no">133</span><span id="line-133">        try {</span>
<span class="source-line-no">134</span><span id="line-134">            if (slotsUsed() != s.slotsUsed() || size() != s.size()) {</span>
<span class="source-line-no">135</span><span id="line-135">                throw new StructuralCodeConstraintException("Cannot merge stacks of different size:\nOperandStack A:\n" + this + "\nOperandStack B:\n" + s);</span>
<span class="source-line-no">136</span><span id="line-136">            }</span>
<span class="source-line-no">137</span><span id="line-137"></span>
<span class="source-line-no">138</span><span id="line-138">            for (int i = 0; i &lt; size(); i++) {</span>
<span class="source-line-no">139</span><span id="line-139">                // If the object _was_ initialized and we're supposed to merge</span>
<span class="source-line-no">140</span><span id="line-140">                // in some uninitialized object, we reject the code (see vmspec2, 4.9.4, last paragraph).</span>
<span class="source-line-no">141</span><span id="line-141">                if (!(stack.get(i) instanceof UninitializedObjectType) &amp;&amp; s.stack.get(i) instanceof UninitializedObjectType) {</span>
<span class="source-line-no">142</span><span id="line-142">                    throw new StructuralCodeConstraintException("Backwards branch with an uninitialized object on the stack detected.");</span>
<span class="source-line-no">143</span><span id="line-143">                }</span>
<span class="source-line-no">144</span><span id="line-144">                // Even harder, we're not initialized but are supposed to broaden</span>
<span class="source-line-no">145</span><span id="line-145">                // the known object type</span>
<span class="source-line-no">146</span><span id="line-146">                if (!stack.get(i).equals(s.stack.get(i)) &amp;&amp; stack.get(i) instanceof UninitializedObjectType</span>
<span class="source-line-no">147</span><span id="line-147">                    &amp;&amp; !(s.stack.get(i) instanceof UninitializedObjectType)) {</span>
<span class="source-line-no">148</span><span id="line-148">                    throw new StructuralCodeConstraintException("Backwards branch with an uninitialized object on the stack detected.");</span>
<span class="source-line-no">149</span><span id="line-149">                }</span>
<span class="source-line-no">150</span><span id="line-150">                // on the other hand...</span>
<span class="source-line-no">151</span><span id="line-151">                if (stack.get(i) instanceof UninitializedObjectType &amp;&amp; !(s.stack.get(i) instanceof UninitializedObjectType)) { // that has been initialized by</span>
<span class="source-line-no">152</span><span id="line-152">                                                                                                                               // now</span>
<span class="source-line-no">153</span><span id="line-153">                    stack.set(i, ((UninitializedObjectType) stack.get(i)).getInitialized()); // note that.</span>
<span class="source-line-no">154</span><span id="line-154">                }</span>
<span class="source-line-no">155</span><span id="line-155">                if (!stack.get(i).equals(s.stack.get(i))) {</span>
<span class="source-line-no">156</span><span id="line-156">                    if (!(stack.get(i) instanceof ReferenceType) || !(s.stack.get(i) instanceof ReferenceType)) {</span>
<span class="source-line-no">157</span><span id="line-157">                        throw new StructuralCodeConstraintException("Cannot merge stacks of different types:\nStack A:\n" + this + "\nStack B:\n" + s);</span>
<span class="source-line-no">158</span><span id="line-158">                    }</span>
<span class="source-line-no">159</span><span id="line-159">                    stack.set(i, ((ReferenceType) stack.get(i)).getFirstCommonSuperclass((ReferenceType) s.stack.get(i)));</span>
<span class="source-line-no">160</span><span id="line-160">                }</span>
<span class="source-line-no">161</span><span id="line-161">            }</span>
<span class="source-line-no">162</span><span id="line-162">        } catch (final ClassNotFoundException e) {</span>
<span class="source-line-no">163</span><span id="line-163">            // FIXME: maybe not the best way to handle this</span>
<span class="source-line-no">164</span><span id="line-164">            throw new AssertionViolatedException("Missing class: " + e, e);</span>
<span class="source-line-no">165</span><span id="line-165">        }</span>
<span class="source-line-no">166</span><span id="line-166">    }</span>
<span class="source-line-no">167</span><span id="line-167"></span>
<span class="source-line-no">168</span><span id="line-168">    /**</span>
<span class="source-line-no">169</span><span id="line-169">     * Returns the element on top of the stack. The element is not popped off the stack!</span>
<span class="source-line-no">170</span><span id="line-170">     */</span>
<span class="source-line-no">171</span><span id="line-171">    public Type peek() {</span>
<span class="source-line-no">172</span><span id="line-172">        return peek(0);</span>
<span class="source-line-no">173</span><span id="line-173">    }</span>
<span class="source-line-no">174</span><span id="line-174"></span>
<span class="source-line-no">175</span><span id="line-175">    /**</span>
<span class="source-line-no">176</span><span id="line-176">     * Returns the element that's i elements below the top element; that means, iff i==0 the top element is returned. The</span>
<span class="source-line-no">177</span><span id="line-177">     * element is not popped off the stack!</span>
<span class="source-line-no">178</span><span id="line-178">     */</span>
<span class="source-line-no">179</span><span id="line-179">    public Type peek(final int i) {</span>
<span class="source-line-no">180</span><span id="line-180">        return stack.get(size() - i - 1);</span>
<span class="source-line-no">181</span><span id="line-181">    }</span>
<span class="source-line-no">182</span><span id="line-182"></span>
<span class="source-line-no">183</span><span id="line-183">    /**</span>
<span class="source-line-no">184</span><span id="line-184">     * Returns the element on top of the stack. The element is popped off the stack.</span>
<span class="source-line-no">185</span><span id="line-185">     */</span>
<span class="source-line-no">186</span><span id="line-186">    public Type pop() {</span>
<span class="source-line-no">187</span><span id="line-187">        return stack.remove(size() - 1);</span>
<span class="source-line-no">188</span><span id="line-188">    }</span>
<span class="source-line-no">189</span><span id="line-189"></span>
<span class="source-line-no">190</span><span id="line-190">    /**</span>
<span class="source-line-no">191</span><span id="line-191">     * Pops i elements off the stack. Always returns null.</span>
<span class="source-line-no">192</span><span id="line-192">     *</span>
<span class="source-line-no">193</span><span id="line-193">     * @return Always returns null.</span>
<span class="source-line-no">194</span><span id="line-194">     */</span>
<span class="source-line-no">195</span><span id="line-195">    public Type pop(final int count) {</span>
<span class="source-line-no">196</span><span id="line-196">        for (int j = 0; j &lt; count; j++) {</span>
<span class="source-line-no">197</span><span id="line-197">            pop();</span>
<span class="source-line-no">198</span><span id="line-198">        }</span>
<span class="source-line-no">199</span><span id="line-199">        return null;</span>
<span class="source-line-no">200</span><span id="line-200">    }</span>
<span class="source-line-no">201</span><span id="line-201"></span>
<span class="source-line-no">202</span><span id="line-202">    /**</span>
<span class="source-line-no">203</span><span id="line-203">     * Pushes a Type object onto the stack.</span>
<span class="source-line-no">204</span><span id="line-204">     */</span>
<span class="source-line-no">205</span><span id="line-205">    public void push(final Type type) {</span>
<span class="source-line-no">206</span><span id="line-206">        if (type == null) {</span>
<span class="source-line-no">207</span><span id="line-207">            throw new AssertionViolatedException("Cannot push NULL onto OperandStack.");</span>
<span class="source-line-no">208</span><span id="line-208">        }</span>
<span class="source-line-no">209</span><span id="line-209">        if (type == Type.BOOLEAN || type == Type.CHAR || type == Type.BYTE || type == Type.SHORT) {</span>
<span class="source-line-no">210</span><span id="line-210">            throw new AssertionViolatedException("The OperandStack does not know about '" + type + "'; use Type.INT instead.");</span>
<span class="source-line-no">211</span><span id="line-211">        }</span>
<span class="source-line-no">212</span><span id="line-212">        if (slotsUsed() &gt;= maxStack) {</span>
<span class="source-line-no">213</span><span id="line-213">            throw new AssertionViolatedException("OperandStack too small, should have thrown proper Exception elsewhere. Stack: " + this);</span>
<span class="source-line-no">214</span><span id="line-214">        }</span>
<span class="source-line-no">215</span><span id="line-215">        stack.add(type);</span>
<span class="source-line-no">216</span><span id="line-216">    }</span>
<span class="source-line-no">217</span><span id="line-217"></span>
<span class="source-line-no">218</span><span id="line-218">    /**</span>
<span class="source-line-no">219</span><span id="line-219">     * Returns the size of this OperandStack; that means, how many Type objects there are.</span>
<span class="source-line-no">220</span><span id="line-220">     */</span>
<span class="source-line-no">221</span><span id="line-221">    public int size() {</span>
<span class="source-line-no">222</span><span id="line-222">        return stack.size();</span>
<span class="source-line-no">223</span><span id="line-223">    }</span>
<span class="source-line-no">224</span><span id="line-224"></span>
<span class="source-line-no">225</span><span id="line-225">    /**</span>
<span class="source-line-no">226</span><span id="line-226">     * Returns the number of stack slots used.</span>
<span class="source-line-no">227</span><span id="line-227">     *</span>
<span class="source-line-no">228</span><span id="line-228">     * @see #maxStack()</span>
<span class="source-line-no">229</span><span id="line-229">     */</span>
<span class="source-line-no">230</span><span id="line-230">    public int slotsUsed() {</span>
<span class="source-line-no">231</span><span id="line-231">        /*</span>
<span class="source-line-no">232</span><span id="line-232">         * XXX change this to a better implementation using a variable that keeps track of the actual slotsUsed()-value</span>
<span class="source-line-no">233</span><span id="line-233">         * monitoring all push()es and pop()s.</span>
<span class="source-line-no">234</span><span id="line-234">         */</span>
<span class="source-line-no">235</span><span id="line-235">        int slots = 0;</span>
<span class="source-line-no">236</span><span id="line-236">        for (int i = 0; i &lt; stack.size(); i++) {</span>
<span class="source-line-no">237</span><span id="line-237">            slots += peek(i).getSize();</span>
<span class="source-line-no">238</span><span id="line-238">        }</span>
<span class="source-line-no">239</span><span id="line-239">        return slots;</span>
<span class="source-line-no">240</span><span id="line-240">    }</span>
<span class="source-line-no">241</span><span id="line-241"></span>
<span class="source-line-no">242</span><span id="line-242">    /**</span>
<span class="source-line-no">243</span><span id="line-243">     * Returns a String representation of this OperandStack instance.</span>
<span class="source-line-no">244</span><span id="line-244">     */</span>
<span class="source-line-no">245</span><span id="line-245">    @Override</span>
<span class="source-line-no">246</span><span id="line-246">    public String toString() {</span>
<span class="source-line-no">247</span><span id="line-247">        final StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">248</span><span id="line-248">        sb.append("Slots used: ");</span>
<span class="source-line-no">249</span><span id="line-249">        sb.append(slotsUsed());</span>
<span class="source-line-no">250</span><span id="line-250">        sb.append(" MaxStack: ");</span>
<span class="source-line-no">251</span><span id="line-251">        sb.append(maxStack);</span>
<span class="source-line-no">252</span><span id="line-252">        sb.append(".\n");</span>
<span class="source-line-no">253</span><span id="line-253">        for (int i = 0; i &lt; size(); i++) {</span>
<span class="source-line-no">254</span><span id="line-254">            sb.append(peek(i));</span>
<span class="source-line-no">255</span><span id="line-255">            sb.append(" (Size: ");</span>
<span class="source-line-no">256</span><span id="line-256">            sb.append(String.valueOf(peek(i).getSize()));</span>
<span class="source-line-no">257</span><span id="line-257">            sb.append(")\n");</span>
<span class="source-line-no">258</span><span id="line-258">        }</span>
<span class="source-line-no">259</span><span id="line-259">        return sb.toString();</span>
<span class="source-line-no">260</span><span id="line-260">    }</span>
<span class="source-line-no">261</span><span id="line-261"></span>
<span class="source-line-no">262</span><span id="line-262">}</span>




























































</pre>
</div>
</main>
</body>
</html>
